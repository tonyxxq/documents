# 设计模式

### 代理模式

> 主要的目的是对代码的功能争增强，实现动态代理有两种方式 jdk方式 和 cglib 方式

```java
public class MyProxyUtils {


    /**
     * 使用 JDK 的方式动态代理（基于接口）
     */
    public static UserService getProxy(final UserService userService) {
        // 第一个参数：目标对象类加载器
        // 第二个参数：目标对象接口
        // 第三个参数：代理对象的执行处理器
        UserService proxy = (UserService) Proxy.newProxyInstance(
                userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(),
                // 监控目标对象的行为，当调用方法时执行如下的代码
                new InvocationHandler() {
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // 增加增强代码
                        System.out.println("记录日志-开始.............");

                        // 该行代码调用的实际是目标对象的方法
                        Object object = method.invoke(userService, args);

                        // 增加增强代码
                        System.out.println("记录日志-结束.............");

                        return object;
                    }
                });

        return proxy;
    }

    /**
     * 使用 Cglib 的方式动态代理（继承的方式）
     */
    public static UserService getCglibProxy(UserService userService) {
        // 创建增强对象
        Enhancer enhancer = new Enhancer();

        // 设置需要增强的类对象
        enhancer.setSuperclass(userService.getClass());

        // 设置回调函数
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {

                System.out.println("记录开始时间：" + System.currentTimeMillis());

                // 该行代码实际调用的是目标对象的方法
                Object object2 = methodProxy.invokeSuper(object, args);

                System.out.println("记录结束时间：" + System.currentTimeMillis());

                return object2;
            }
        });

        // 获取增强之后的类
        return (UserService) enhancer.create();
    }
}
```

### 装饰者模式

> 装饰模式可以将一个目标库增强（类似代理模式）
>
> 1. 装饰类和被装饰类都实现相同的接口
> 2. 把目标类**对象**使用构造方法的方式传递给装饰类

接口内

```java
public interface Iphone {
    public void call();
}
```

被装饰类（目标类）

```java
public class Iphone6 implements Iphone{
    public void call() {
        System.out.println("Iphone6 打电话，信号好！！！");
    }
}
```

装饰类

```java
public class IphoneDecorate implements Iphone {

    // 被装饰目标对象
    private Iphone iphone;

    // 通过构造参数将目标对象传过来哦
    public IphoneDecorate(Iphone iphone) {
        super();
        this.iphone = iphone;
    }

    public void call() {
        System.out.println("播放一首歌");
        iphone.call();
    }
}
```

测试

```java
public static void main(String[] args) {
    Iphone iphone = new Iphone6();

    iphone.call();

    System.out.println("-----------");

    Iphone iphone2 = new IphoneDecorate(iphone);
    iphone2.call();
}
```

输出：

```
Iphone6 打电话，信号好！！！
-----------
播放一首歌
Iphone6 打电话，信号好！！！
```

### 适配器模式

> 使用一个标准将不同的标准统一起来

德标接口

```java
public interface DBSocket {
    void charge();
}
```

德标实现

```java
public class DBSocketImpl implements DBSocket{

    public void charge() {
        System.out.println("使用两眼插孔");
    }
}
```

国标接口

```jade
public interface GBSocket {
    void charge();
}
```

国标实现

```jade
public class GBSocketImpl implements DBSocket{

    public void charge() {
        System.out.println("使用三眼插孔");
    }
}
```

国际标准接口

```java
public interface GJBZSocket {
    void charge();
}
```

国际标准实现

```java
public class GJBZSocketImpl implements GJBZSocket{

    private Object socket;

    public GJBZSocketImpl(Object socket){
        this.socket = socket;
    }

    public void charge() {
        if (socket instanceof GBSocket){
            ((GBSocket) socket).charge();
        } else if(socket instanceof DBSocket){
            ((DBSocket) socket).charge();
        }
    }
}
```

测试

```java
public class TestAdapter {
    public static void main(String[] args) {
        DBSocket dbSocket = new DBSocketImpl();
        GJBZSocket gjbzSocket1 = new GJBZSocketImpl(dbSocket);
        gjbzSocket1.charge();

        System.out.println("---------------------");

        GBSocket gbSocket = new GBSocketImpl();
        GJBZSocket gjbzSocket2 = new GJBZSocketImpl(gbSocket);
        gjbzSocket2.charge();
    }
}
```

输出

```
使用两眼插孔
---------------------
使用三眼插孔
```



