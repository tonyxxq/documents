

​	死锁：两个进程之间都有对象需要的资源，都不放手，

​	活锁： 一个进程需要别的进程释放资源



#### 同步、异步、阻塞、非阻塞

同步：发送方发送请求之后，需要等接收方发回响应后才接着发，一直处于轮询状态

异步：发送方发送一个请求之后不等待接收方响应这个请求，就继续发送下个请求，请求成功之后执行**回调**

函数通知发送方

阻塞调用 ：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回，该线程在此过程中不能进行其他处理

非阻塞调用：调用结果不能马上返回，当前线程也不会被挂起，而是立即返回执行下一个调用

**注意：区分同步和异步看是是否接收方有请求方的回调函数，并不是说在一个线程里边就是同步，比如：观察者模式就是异步的表现，在被观察者状态变化的时候才会回调观察者的方法，期间观察者并没有一直处于等待状态；区分阻塞和非阻塞看是否使线程被挂起**

#### CompletableFuture 编程

CompletableFuture 可以使用函数式编程方式完成异步调用，虽然在每个方法内部可以完成异步的操作，但是后面的需要依赖前面的执行结果,也是属于串行执行，依然是同一个线程，感觉有点鸡肋

> 注意：异步操作只在调用方法执行比较慢的情况下使用，一般的方法没有必要使用，因为开启线程也是需要花时间的

下面只是简单的用法，还有稍微高级点的用法，之后再了解

```java
public class Main {
    public static void main(String[] args) throws Exception {

        // supplyAsync 提供异步调用方法
        // thenApplyAsync，thenApply 表示使用上一步前的结果作为输入
        // whenComplete 第一个参数表示上一步的返回结果；第二个参数表示前面出现的异常
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> s + " world")
                .thenApplyAsync(s -> s + " ！")
                .whenComplete((r, e) -> {
                    if (e == null) {
                        System.out.println(r);
                    } else {
                        e.printStackTrace();
                    }
                });

        // thenAccept 表示使用前一个的值作为参数，没有返回值
        // thenRun 表示不使用之前的返回值
        // 这两个方法一般作为执行的结束
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> s + " world")
                .thenApplyAsync(s -> s + " ！")
                .thenAccept((r) -> System.out.println(r));
        //  .thenRun(()-> System.out.println("xxxx"));

        TimeUnit.SECONDS.sleep(10);
    }
}
```

看一下同步和异步

```java
public class Main {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> {
                    System.out.println(Thread.currentThread().getName());
                    return s + " world";
                })
                .thenApplyAsync(s -> {
                    System.out.println(Thread.currentThread().getName());
                    return s + " ！";
                })
                .whenComplete((r, e) -> {
                    System.out.println(Thread.currentThread().getName());
                });


        TimeUnit.SECONDS.sleep(2);
    }
}
```

输出为：

```
main
ForkJoinPool.commonPool-worker-9
ForkJoinPool.commonPool-worker-9
```

可以看到所谓的异步只是和 main 线程的异步，其实他们整个方法流使用的还是同一个线程，因为他们有依赖

### CountDownLatch

> 举例：
>
> 1. 多线程读取批量文件, 并且读取完成之后汇总处理
>
> 2. 多线程读取Excel多个sheet,读取完成之后获取汇总获取的结果
>
> 3. 多个人一起一起来吃饭,主人等待客人到来,客人一个个从不同地方来到饭店,主人需要等到所有人都到来之后,才能开饭
>
> 4. 汽车站,所有乘客都从不同的地方赶到汽车站,必须等到所有乘客都到了,汽车才会出发,如果设置了超时等待,那么当某个时间点到了,汽车也出发
>
> 
>
> 作用是主线程等待子线程执行完成，才执行后续操作，不然进行阻塞
>
> CountDownLatch 的构造参数为需要多少个子线程执行 countDown，才执行主线程（数量不一定和主线程一致，如果一致表示所有的子线程执行完 countDown 方法）
>
> countDown：子线程调用一次，表示已完成数量加 1
>
> await： 等待子线程执行完指定的数量

```java
public class Test {

    public static void main(String[] args) {
        // 设置 3 个子线程完成之后
        CountDownLatch cdl = new CountDownLatch(3);

        for (int i = 0; i < 3; i++) {
            Thread thread = new Thread(new Player(cdl));
            thread.start();
        }

        try {
            // 主线程等待子线程 countDown 执行数量
            cdl.await();
            System.out.println("执行主线程");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Player implements Runnable {

    private CountDownLatch cdl;

    Player(CountDownLatch cdl) {
        this.cdl = cdl;
    }

    public void run() {
        try {
            // 子线程休息 1 秒
            TimeUnit.SECONDS.sleep(1);
            System.out.println(Thread.currentThread().getName() + " arrived !");
            // 线程执行数量减 1
            cdl.countDown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



