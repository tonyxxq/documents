# 基础

#### 位运算和移位运算

> 左移一位相当于乘以 2，右移一位相当于除以 2
>
> 如果是负数：>> 符号位不会跟着走， >>> 符号位会跟着走

```java
n = 0 & 0; // 0，与运算的规则是，必须两个数同时为1，结果才为1
n = 0 | 0; // 0，或运算的规则是，只要任意一个为1，结果就为1
n = ~0;    // 1，非运算的规则是，0和1互换，就是补码
n = 0 ^ 1; // 1，异或运算的规则是，如果两个数不同，结果为1，否则为0

int n = 7;       // 00000000 0000000 0000000 00000111
int a = n << 1;  // 00000000 0000000 0000000 00001110 <= 14

int n = -536870912;
int a = n >> 1;  // 11110000 0000000 0000000 00000000 <= -268435456

int n = -536870912;
int a = n >>> 1;  // 01110000 0000000 0000000 00000000 <= 1879048192
```

十进制和二进制的转换：<https://jingyan.baidu.com/album/597a0643614568312b5243c0.html?picindex=1>

#### 函数式编程

> 注意：函数式接口，它指的是**有且只有一个未实现**（不包括 Object 方法）的方法的接口，一般通过 `@FunctionalInterface` 这个注解来表明某个接口是一个函数式接口，这样在实现的时候不用写接口名，因为默认就是这个接口的实现

已经内置的函数式接口，比如：Consumer， Function， Predicate 等

Consumer 函数式接口，只有一个输入，没有返回值

```java
@FunctionalInterface
public interface Consumer<T> {
    // 只有这一个接口方法
     void accept(T t);
}
```

创建函数式接口对象并调用函数方法

```java
Consumer<Integer> c = System.out::println;
c.accept(1); // 输出 1
```

Function  函数式接口包括 apply 、compose、andThen、indentity 四个方法

```java
// 默认实现 apply 接口方法
Function<Integer, Integer> f = (s) -> s * s;
Function<Integer, Integer> g = (s) -> s + s;

System.out.println(f.apply(10));  // 执行函数
System.out.println(f.andThen(g).apply(10)); // 先执行 f 再执行 g
System.out.println(f.compose(g).apply(10)); // 先执行 g 再执行 f
System.out.println(Function.identity().apply(10)); // 静态方法，什么也不做，输入什么输出什么
```

Predicate 函数式接口，判断某个东西是否满足某种条件，包含：and、or、negate、test 方法

```java
// 默认实现 test 接口方法
Predicate<String> p = o -> o.equals("test");
Predicate<String> q = o -> o.startsWith("t");

System.out.println(p.and(q).test("taste")); 
System.out.println(p.or(q).test("taste"));
System.out.println(p.or(q).negate().test("taste")); // negate 表示取结果的反面
```

Stream 对象提供多个非常有用的方法，如： map，flatMap，filter，reduce ，collect 等等

flatMap 和 map 的区别

> flatMap：  每个元素映射结果是 1 对 多，如下：s.split("") 得到的结果是个数组，会把它进行展开
>
> map：每个元素的映射结果是 1 对 1，如下：s.split("") 得到的结果是个数组，不会把它进行展开

```java
Stream.of("aaa").flatMap(s -> Stream.of(s.split(""))).forEach(System.out::println);
Stream.of("aaa").map(s -> Stream.of(s.split(""))).forEach(System.out::println);
```

输出：

```
a
a
a
java.util.stream.ReferencePipeline$Head@4e04a765
```

Optional

> 为什么使用 Optional，因为写代码的时候很容易出现空指针异常，如果使用 Optional 包裹一下就不会出现这种问题，用于简化Java中对空值的判断处理，以防止出现各种空指针异常。
>
> 其中包括 get，isPresent，ifPresent，ifPresentOrElse，map，filter，else，orElse，orElseGet，orElseThrow 等方法

如下：当 test 为空或不为空的时候可以进行一些处理的时候

```java
String test="1";
Optional<String> optional = Optional.ofNullable(test);

optional.ifPresent((s) -> System.out.println(s));
System.out.println(optional.orElse("null"));
optional.orElseGet(()->"this is null");
optional.orElseThrow(() -> new Exception("msg"));
```

#### 关于锁

死锁：两个进程之间都有对象需要的资源，都不放手，

活锁： 一个进程需要别的进程释放资源

#### 同步、异步、阻塞、非阻塞

同步：发送方发送请求之后，需要等接收方发回响应后才接着发，一直处于轮询状态

异步：发送方发送一个请求之后不等待接收方响应这个请求，就继续发送下个请求，请求成功之后执行**回调**

函数通知发送方

阻塞调用 ：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回，该线程在此过程中不能进行其他处理

非阻塞调用：调用结果不能马上返回，当前线程也不会被挂起，而是立即返回执行下一个调用

**注意：区分同步和异步看是是否接收方有请求方的回调函数，并不是说在一个线程里边就是同步，比如：观察者模式就是异步的表现，在被观察者状态变化的时候才会回调观察者的方法，期间观察者并没有一直处于等待状态；区分阻塞和非阻塞看是否使线程被挂起**

#### CompletableFuture 编程

CompletableFuture 可以使用函数式编程方式完成异步调用，虽然在每个方法内部可以完成异步的操作，但是后面的需要依赖前面的执行结果,也是属于串行执行，依然是同一个线程，感觉有点鸡肋

> 注意：异步操作只在调用方法执行比较慢的情况下使用，一般的方法没有必要使用，因为开启线程也是需要花时间的

下面只是简单的用法，还有稍微高级点的用法，之后再了解

```java
public class Main {
    public static void main(String[] args) throws Exception {

        // supplyAsync 提供异步调用方法
        // thenApplyAsync，thenApply 表示使用上一步前的结果作为输入
        // whenComplete 第一个参数表示上一步的返回结果；第二个参数表示前面出现的异常
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> s + " world")
                .thenApplyAsync(s -> s + " ！")
                .whenComplete((r, e) -> {
                    if (e == null) {
                        System.out.println(r);
                    } else {
                        e.printStackTrace();
                    }
                });

        // thenAccept 表示使用前一个的值作为参数，没有返回值
        // thenRun 表示不使用之前的返回值
        // 这两个方法一般作为执行的结束
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> s + " world")
                .thenApplyAsync(s -> s + " ！")
                .thenAccept((r) -> System.out.println(r));
        //  .thenRun(()-> System.out.println("xxxx"));

        TimeUnit.SECONDS.sleep(10);
    }
}
```

看一下同步和异步

```java
public class Main {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> "hello")
                .thenApply(s -> {
                    System.out.println(Thread.currentThread().getName());
                    return s + " world";
                })
                .thenApplyAsync(s -> {
                    System.out.println(Thread.currentThread().getName());
                    return s + " ！";
                })
                .whenComplete((r, e) -> {
                    System.out.println(Thread.currentThread().getName());
                });


        TimeUnit.SECONDS.sleep(2);
    }
}
```

输出为：

```
main
ForkJoinPool.commonPool-worker-9
ForkJoinPool.commonPool-worker-9
```

可以看到所谓的异步只是和 main 线程的异步，其实他们整个方法流使用的还是同一个线程，因为他们有依赖

#### CountDownLatch

> 举例：
>
> 1. 多线程读取批量文件, 并且读取完成之后汇总处理
>
> 2. 多线程读取Excel多个sheet,读取完成之后获取汇总获取的结果
>
> 3. 多个人一起一起来吃饭,主人等待客人到来,客人一个个从不同地方来到饭店,主人需要等到所有人都到来之后,才能开饭
>
> 4. 汽车站,所有乘客都从不同的地方赶到汽车站,必须等到所有乘客都到了,汽车才会出发,如果设置了超时等待,那么当某个时间点到了,汽车也出发
>
> 
>
> 作用是主线程等待子线程执行完成，才执行后续操作，不然进行阻塞
>
> CountDownLatch 的构造参数为需要多少个子线程执行 countDown，才执行主线程（数量不一定和主线程一致，如果一致表示所有的子线程执行完 countDown 方法）
>
> countDown：子线程调用一次，表示已完成数量加 1
>
> await： 等待子线程执行完指定的数量

```java
public class Test {

    public static void main(String[] args) {
        // 设置 3 个子线程完成之后
        CountDownLatch cdl = new CountDownLatch(3);

        for (int i = 0; i < 3; i++) {
            Thread thread = new Thread(new Player(cdl));
            thread.start();
        }

        try {
            // 主线程等待子线程 countDown 执行数量
            cdl.await();
            System.out.println("执行主线程");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Player implements Runnable {

    private CountDownLatch cdl;

    Player(CountDownLatch cdl) {
        this.cdl = cdl;
    }

    public void run() {
        try {
            // 子线程休息 1 秒
            TimeUnit.SECONDS.sleep(1);
            System.out.println(Thread.currentThread().getName() + " arrived !");
            // 线程执行数量减 1
            cdl.countDown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



